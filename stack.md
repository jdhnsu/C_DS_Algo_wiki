# 栈
## 为什么要了解栈
    栈是计算机科学的一种非常基础的数据结构,在计算机中有广泛的应用,例如:函数的调用,以及括号匹配等等.
## 什么是栈?
  栈是一种遵循先入后出的线性数据结构,即最后进入栈的元素最先被移除。它可以被视为一个垂直的容器，元素只能从顶部添加或移除.
## 栈的基本操作
**压栈(push)**: 如果将栈比作羽毛球桶,压栈就是将羽毛球放入桶中,并且只能放在已有羽毛球的顶部.jj


**弹栈(pop)**: 弹栈就好比从羽毛球桶中取出顶部的羽毛球,并且只能取出顶部的羽毛球,如果想取出较为底部的羽毛球,就需要先将顶部的羽毛球取出.

**查看栈顶元素(peek)**: 这个很好理解,好比查看羽毛球桶顶部的羽毛球是什么样的,但并不将其取出.

 **检查栈是否为空(is_empty)**: 出发打球前检查是否有羽毛球,如果没有羽毛球,就不能打球了.


**获取栈的大小(size)**: 这个操作就好比数一下羽毛球桶中有多少个羽毛球,返回的就是羽毛球的数量.

## 栈的实现
  栈的实现可以通过数组和链表模拟实现,并且只要理解了栈的功能实现是十分简单的.例如这里设计一个简单的栈(只展示入栈):
  ```c
  typedef struct stack {
  elem_type data[MAX];
  int top;
  }stack;
  
  void stack_push(stack *s,elem_type val)
  {
    if (stack->top + 1 >= MAX) // 如果超出数组范围继续插入会导致数组访问越界.并且因为(top)从-1开始计数.
    {
        printf("Stack overflow [From: push_array_stack()]\n");
        return;
    }
    stack->top++;     // top指向栈顶的位置.然后插入val;
    stack->data[stack->top] = val;
  }
  ```
  简单理解上述的例子就可以发现一个很大的问题,就是一旦top到达数组的边界,就无法继续使用该栈了.那么我们在程序初期的数组的大小设定成为了影响灵活性的关键设定.之前提到过`链表`相较于`数组`的优势中提到过**动态扩展**这一个特性,那么我们就可以通过`链表`来设计一个可以动态拓展的`栈`.
  ### 代码查看
  [linked_list_stack.h](https://github.com/jdhnsu/C_DS_Algo/blob/main_jdh/linked_list_stack.h)
  [linked_list_stack.c](https://github.com/jdhnsu/C_DS_Algo/blob/main_jdh/linked_list_stack.c)

  ## 两种栈的效率分析
`数组栈`的入出栈的效率一般来讲效率是更高的,以为数组是一段连续的内存空间,具有更好的缓存连续性,因此效率更高,但是拓展性较差,相反`链表栈`的拓展性虽然更好,但是出入栈的效率较为低一点,应为内穿较为分散,连续性差,所以效率略低.